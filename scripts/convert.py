# Generated by Gemini (Fast)
#
# This script converts WLED JSON preset backups of Pipplee (https://pipplee.com/) generated WLED config 
# into C++ header files suitable for use in an Arduino project with a 16x16 LED matrix.

import json
import os
import sys
import shutil

# Configuration
ANIMATIONS_DIR = "animations_src"
INCLUDE_DIR = "include/animations"
MASTER_HEADER = os.path.join(INCLUDE_DIR, "animations.h")
PIXEL_COUNT = 256 # Assuming 16x16 matrix

def generate_animation_header(file_path, base_name, width, height):
    """Generates a single header file for one animation."""
    
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
    except Exception as e:
        print(f"Error reading/parsing {file_path}: {e}")
        return None

    preset_keys = sorted(data.keys(), key=lambda x: int(x))
    
    # Exclude preset "0" and the last one (the playlist)
    presets_to_use = preset_keys[1:-1]
    frames_data = []
    
    # Extract durations from the playlist preset (the last preset)
    playlist_key = preset_keys[-1]
    frame_durations_float = [2.0] * len(presets_to_use)
    
    try:
        frame_durations_float = data[playlist_key]['playlist']['dur']
    except (KeyError, TypeError):
        print(f"Warning: No durations found in {base_name}. Using default 2 (0.2s).")

    frame_durations = [int(round(d)) for d in frame_durations_float]

    # 2. Extract pixel data
    for key in presets_to_use:
        try:
            frame_pixels = data[key]['seg']['i']
            if len(frame_pixels) != PIXEL_COUNT:
                print(f"Warning: Preset {key} in {base_name} has {len(frame_pixels)} pixels, expected {PIXEL_COUNT}. Skipping frame.")
                continue
            
            flat_pixels = [val for sublist in frame_pixels for val in sublist]
            frames_data.append(flat_pixels)
        except (KeyError, TypeError) as e:
            print(f"Warning: Skipping preset {key} in {base_name}: {e}")

    num_frames = len(frames_data)
    
    # If no valid frames were found, skip generation
    if num_frames == 0:
        print(f"Warning: No valid frames extracted for {base_name}. Skipping file generation.")
        return None

    # 3. Generate the Header Content
    HEADER_GUARD = f"ANIMATION_{base_name.upper()}_H"
    
    # Array names are unique using the base name
    frames_array_name = f"{base_name}Frames"
    durations_array_name = f"{base_name}Durations"
    struct_name = f"{base_name}Animation"

    header_content = [
        f"// {base_name}.h - Auto-generated from {os.path.basename(file_path)}",
        f"#ifndef {HEADER_GUARD}",
        f"#define {HEADER_GUARD}",
        "",
        '#include "animation_types.h"', # Include the struct definition
        "",
        f"// Frame Durations for {base_name} (in 100ms units)",
        f"static const uint8_t PROGMEM {durations_array_name}[] = {{ {', '.join(map(str, frame_durations[:num_frames]))} }};",
        "",
        f"// RGB Frame Data for {base_name}",
        f"static const uint8_t PROGMEM {frames_array_name}[] = {{",
    ]

    # Format pixel array content
    all_pixels = [str(val) for frame in frames_data for val in frame]
    pixel_lines = []
    for i in range(0, len(all_pixels), 12):
        pixel_lines.append("  " + ", ".join(all_pixels[i:i+12]))

    header_content.append(",\n".join(pixel_lines))
    header_content.append("};")
    header_content.append("")
    
    # Generate the Animation struct instance
    header_content.append(f"const Animation {struct_name} = {{")
    header_content.append(f"  .frameCount = {num_frames},")
    header_content.append(f"  .width = {width},")
    header_content.append(f"  .height = {height},")
    header_content.append(f"  .frameDurations = {durations_array_name},")
    header_content.append(f"  .animationFrames = {frames_array_name}")
    header_content.append("};")
    
    header_content.append(f"#endif // {HEADER_GUARD}")
    header_content.append("")
    
    # 4. Write the file
    output_path = os.path.join(INCLUDE_DIR, f"{base_name}.h")
    with open(output_path, 'w') as f:
        f.write("\n".join(header_content))

    print(f"-> Generated {output_path} with {num_frames} frames.")
    return struct_name

def generate_master_header(animation_struct_names):
    """Generates the main animations.h file."""
    
    master_content = [
        "// animations.h - Master file with all animation includes and array",
        "#ifndef MASTER_ANIMATIONS_H",
        "#define MASTER_ANIMATIONS_H",
        "",
        '#include "animation_types.h"',
        ""
    ]
    
    # Includes for all individual animation headers
    for name in animation_struct_names:
        master_content.append(f'#include "{name.replace("Animation", "")}.h"')
        
    master_content.append("")
    
    # Global array of all animation structs
    struct_list = ", ".join(animation_struct_names)
    master_content.append(f"// Global array of all available animations")
    master_content.append(f"const Animation allAnimations[] = {{ {struct_list} }};")
    master_content.append(f"const uint8_t TOTAL_ANIMATIONS = sizeof(allAnimations) / sizeof(Animation);")
    
    master_content.append("")
    master_content.append("#endif // MASTER_ANIMATIONS_H")
    
    # Write the file
    with open(MASTER_HEADER, 'w') as f:
        f.write("\n".join(master_content))
        
    print(f"\nâœ… Generated master header: **{MASTER_HEADER}** with {len(animation_struct_names)} animations.")



# Setup directories
if not os.path.exists(ANIMATIONS_DIR):
    print(f"Error: Directory '{ANIMATIONS_DIR}' not found. Please create it and put your JSON files inside.")
    sys.exit(1)

shutil.rmtree(INCLUDE_DIR, ignore_errors=True)    
if not os.path.exists(INCLUDE_DIR):
    os.makedirs(INCLUDE_DIR)
    
# Create the animation_types.h file
with open(os.path.join(INCLUDE_DIR, "animation_types.h"), 'w') as f:
    f.write("""#ifndef ANIMATION_TYPES_H
#define ANIMATION_TYPES_H
#include <stdint.h>
#include <Arduino.h>

typedef struct {
    const uint16_t frameCount;
    const uint8_t width; 
    const uint8_t height; 
    const uint8_t *frameDurations; 
    const uint8_t *animationFrames; 
} Animation;

#endif
""")
    
print("Starting WLED animation conversion...")

animation_struct_names = []

for filename in os.listdir(ANIMATIONS_DIR):
    if filename.endswith(".json"):
        file_path = os.path.join(ANIMATIONS_DIR, filename)
        base_name = os.path.splitext(filename)[0] # e.g., "gnome"
        
        # Assuming a fixed 16x16 matrix 
        struct_name = generate_animation_header(file_path, base_name, 16, 16)
        
        if struct_name:
            animation_struct_names.append(struct_name)

if animation_struct_names:
    generate_master_header(animation_struct_names)
else:
    print("No valid JSON animations were processed.")